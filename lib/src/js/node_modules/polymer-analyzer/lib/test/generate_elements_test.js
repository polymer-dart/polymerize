/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const chai_1 = require('chai');
const fs = require('fs');
const path = require('path');
const analyzer_1 = require('../analyzer');
const generate_elements_1 = require('../generate-elements');
const fs_url_loader_1 = require('../url-loader/fs-url-loader');
const package_url_resolver_1 = require('../url-loader/package-url-resolver');
const onlyTests = new Set([]); // Should be empty when not debugging.
// TODO(rictic): work out how we want to handle ignoring elements from other
//     packages in the world of Document rather than Analysis.
const skipTests = new Set(['bower_packages', 'nested-packages']);
suite('elements.json generation', function () {
    const basedir = path.join(__dirname, 'static', 'analysis');
    const analysisFixtureDirs = fs.readdirSync(basedir)
        .map(p => path.join(basedir, p))
        .filter(p => fs.statSync(p).isDirectory());
    for (const analysisFixtureDir of analysisFixtureDirs) {
        // Generate a test from the goldens found in every dir in
        // src/test/static/analysis/
        const testBaseName = path.basename(analysisFixtureDir);
        const testDefiner = onlyTests.has(testBaseName) ?
            test.only :
            skipTests.has(testBaseName) ? test.skip : test;
        const testName = `produces a correct elements.json ` +
            `for fixture dir \`${testBaseName}\``;
        testDefiner(testName, function () {
            return __awaiter(this, void 0, void 0, function* () {
                // Test body here:
                const elements = yield analyzeDir(analysisFixtureDir);
                const packages = new Set(mapI(filterI(walkRecursively(analysisFixtureDir), (p) => p.endsWith('bower.json') || p.endsWith('package.json')), (p) => path.dirname(p)));
                if (packages.size === 0) {
                    packages.add(analysisFixtureDir);
                }
                for (const packagePath of packages) {
                    const pathToGolden = path.join(packagePath || '', 'elements.json');
                    const renormedPackagePath = packagePath ?
                        packagePath.substring(analysisFixtureDir.length + 1) :
                        packagePath;
                    const analyzedPackages = generate_elements_1.generateElementMetadata(elements, renormedPackagePath);
                    generate_elements_1.validateElements(analyzedPackages);
                    try {
                        chai_1.assert.deepEqual(analyzedPackages, JSON.parse(fs.readFileSync(pathToGolden, 'utf-8')), `Generated form of ${path.relative(__dirname, pathToGolden)} ` +
                            `differs from the golden at that path`);
                    }
                    catch (e) {
                        console.log(`Expected contents of ${pathToGolden}:\n` +
                            `${JSON.stringify(analyzedPackages, null, 2)}`);
                        throw e;
                    }
                }
            });
        });
    }
    test('throws when validating valid elements.json', function () {
        try {
            generate_elements_1.validateElements({});
        }
        catch (err) {
            chai_1.assert.instanceOf(err, generate_elements_1.ValidationError);
            let valError = err;
            chai_1.assert(valError.errors.length > 0);
            chai_1.assert.include(valError.message, `requires property "elements"`);
            return;
        }
        throw new Error('expected Analysis validation to fail!');
    });
    test(`doesn't throw when validating a valid elements.json`, function () {
        generate_elements_1.validateElements({ elements: [], schema_version: '1.0.0' });
    });
    test(`doesn't throw when validating a version from the future`, function () {
        generate_elements_1.validateElements({ elements: [], schema_version: '1.0.1', new_field: 'stuff here' });
    });
    test(`throws when validating a bad version`, function () {
        try {
            generate_elements_1.validateElements({
                elements: [],
                schema_version: '5.1.1',
                new_field: 'stuff here'
            });
        }
        catch (e) {
            chai_1.assert.include(e.message, 'Invalid schema_version in AnalyzedPackage');
            return;
        }
        throw new Error('expected Analysis validation to fail!');
    });
});
function* filterI(it, pred) {
    for (const inst of it) {
        if (pred(inst)) {
            yield inst;
        }
    }
}
function* mapI(it, trans) {
    for (const inst of it) {
        yield trans(inst);
    }
}
function* walkRecursively(dir) {
    for (const filename of fs.readdirSync(dir)) {
        const fullPath = path.join(dir, filename);
        if (fs.statSync(fullPath).isDirectory()) {
            for (const f of walkRecursively(fullPath)) {
                yield f;
            }
        }
        else {
            yield fullPath;
        }
    }
}
function analyzeDir(baseDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const analyzer = new analyzer_1.Analyzer({
            urlLoader: new fs_url_loader_1.FSUrlLoader(baseDir),
            urlResolver: new package_url_resolver_1.PackageUrlResolver(),
        });
        let importStatements = Array.from(filterI(walkRecursively(baseDir), (f) => f.endsWith('.html')))
            .map(fn => `<link rel="import" href="${path.relative(baseDir, fn)}">`);
        const document = yield analyzer.analyze(path.join('ephemeral.html'), importStatements.join('\n'));
        return Array.from(document.getByKind('element'));
    });
}

//# sourceMappingURL=generate_elements_test.js.map
