{"version":3,"sources":["typescript/typescript-preparser.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;;;AAEH,iCAAiC;AAEjC,0CAAiE;AAEjE,gDAAsE;AAEtE,+DAA+D;AAE/D;;;;;;;;;;;;GAYG;AACH;IACE,KAAK,CAAC,QAAgB,EAAE,GAAW,EAAE,UAA+B;QAElE,MAAM,QAAQ,GAAG,CAAC,CAAC,UAAU,CAAC;QAC9B,UAAU,GAAG,UAAU,IAAI,EAAE,CAAC;QAC9B,MAAM,UAAU,GACZ,EAAE,CAAC,gBAAgB,CAAC,GAAG,EAAE,QAAQ,EAAE,EAAE,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QACrE,MAAM,WAAW,GACb,CAAC,UAAU,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAAoB,CAAC;QAC9D,MAAM,UAAU,GACZ,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,QAAQ,KAAK,EAAE,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;QACxE,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YACf,MAAM,KAAK,GAAG,UAAU,CAAC,6BAA6B,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACzE,MAAM,GAAG,GAAG,UAAU,CAAC,6BAA6B,CAChD,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;YAC1C,MAAM,IAAI,kCAAwB,CAAC;gBACjC,IAAI,EAAE,aAAa;gBACnB,QAAQ,EAAE,kBAAQ,CAAC,KAAK;gBACxB,OAAO,EAAE,EAAE,CAAC,4BAA4B,CAAC,UAAU,CAAC,WAAW,EAAE,IAAI,CAAC;gBACtE,WAAW,EAAE,0BAAkB,CAC3B;oBACE,IAAI,EAAE,GAAG;oBACT,KAAK,EAAE,EAAC,MAAM,EAAE,KAAK,CAAC,SAAS,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,EAAC;oBAClD,GAAG,EAAE,EAAC,MAAM,EAAE,GAAG,CAAC,SAAS,EAAE,IAAI,EAAE,GAAG,CAAC,IAAI,EAAC;iBAC7C,EACD,UAAU,CAAC,cAAc,CAAE;aAChC,CAAC,CAAC;QACL,CAAC;QACD,MAAM,CAAC,IAAI,8CAAwB,CAAC;YAClC,GAAG;YACH,QAAQ;YACR,GAAG,EAAE,UAAU;YACf,cAAc,EAAE,UAAU,CAAC,cAAc;YACzC,OAAO,EAAE,UAAU,CAAC,OAAO,EAAE,QAAQ;SACtC,CAAC,CAAC;IACL,CAAC;CACF;AApCD,kDAoCC","file":"typescript-preparser.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as ts from 'typescript';\n\nimport {correctSourceRange, InlineDocInfo} from '../model/model';\nimport {Parser} from '../parser/parser';\nimport {Severity, WarningCarryingException} from '../warning/warning';\n\nimport {ParsedTypeScriptDocument} from './typescript-document';\n\n/**\n * A TypeScript parser that only parses a single file, not imported files.\n * This parser is suitable for parsing ES6 as well.\n *\n * This parser uses a TypeScript CompilerHost that resolves all imported\n * modules to null, and resolve the standard library to an empty file.\n * Type checking against the result will be riddled with errors, but the\n * parsed AST can be used to find imports.\n *\n * This parser may eventually be replaced with a lightweight parser that\n * can find import statements, but due to the addition of the import()\n * function, it could be that a full parse is needed anyway.\n */\nexport class TypeScriptPreparser implements Parser<ParsedTypeScriptDocument> {\n  parse(contents: string, url: string, inlineInfo?: InlineDocInfo<any>):\n      ParsedTypeScriptDocument {\n    const isInline = !!inlineInfo;\n    inlineInfo = inlineInfo || {};\n    const sourceFile =\n        ts.createSourceFile(url, contents, ts.ScriptTarget.ES2016, true);\n    const diagnostics =\n        (sourceFile['parseDiagnostics'] || []) as ts.Diagnostic[];\n    const parseError =\n        diagnostics.find((d) => d.category === ts.DiagnosticCategory.Error);\n    if (parseError) {\n      const start = sourceFile.getLineAndCharacterOfPosition(parseError.start);\n      const end = sourceFile.getLineAndCharacterOfPosition(\n          parseError.start + parseError.length);\n      throw new WarningCarryingException({\n        code: 'parse-error',\n        severity: Severity.ERROR,\n        message: ts.flattenDiagnosticMessageText(parseError.messageText, '\\n'),\n        sourceRange: correctSourceRange(\n            {\n              file: url,\n              start: {column: start.character, line: start.line},\n              end: {column: end.character, line: end.line}\n            },\n            inlineInfo.locationOffset)!\n      });\n    }\n    return new ParsedTypeScriptDocument({\n      url,\n      contents,\n      ast: sourceFile,\n      locationOffset: inlineInfo.locationOffset,\n      astNode: inlineInfo.astNode, isInline,\n    });\n  }\n}\n"]}