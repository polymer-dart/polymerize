{"version":3,"sources":["javascript/esutil.ts"],"names":[],"mappings":"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","file":"esutil.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as estraverse from 'estraverse';\nimport * as estree from 'estree';\n\nimport {ScannedEvent, SourceRange} from '../model/model';\nimport {annotateEvent} from '../polymer/docs';\nimport {Severity, WarningCarryingException} from '../warning/warning';\n\nimport * as jsdoc from './jsdoc';\n\n/**\n * Returns whether an Espree node matches a particular object path.\n *\n * e.g. you have a MemberExpression node, and want to see whether it represents\n * `Foo.Bar.Baz`:\n *    matchesCallExpressio\n    (node, ['Foo', 'Bar', 'Baz'])\n *\n * @param {ESTree.Node} expression The Espree node to match against.\n * @param {Array<string>} path The path to look for.\n */\nexport function matchesCallExpression(\n    expression: estree.MemberExpression, path: string[]): boolean {\n  if (!expression.property || !expression.object) {\n    return false;\n  }\n  console.assert(path.length >= 2);\n\n  if (expression.property.type !== 'Identifier') {\n    return false;\n  }\n  // Unravel backwards, make sure properties match each step of the way.\n  if (expression.property.name !== path[path.length - 1]) {\n    return false;\n  }\n  // We've got ourselves a final member expression.\n  if (path.length === 2 && expression.object.type === 'Identifier') {\n    return expression.object.name === path[0];\n  }\n  // Nested expressions.\n  if (path.length > 2 && expression.object.type === 'MemberExpression') {\n    return matchesCallExpression(\n        expression.object, path.slice(0, path.length - 1));\n  }\n\n  return false;\n}\n\n/**\n * @param {Node} key The node representing an object key or expression.\n * @return {string} The name of that key.\n */\nexport function objectKeyToString(key: estree.Node): string|undefined {\n  if (key.type === 'Identifier') {\n    return key.name;\n  }\n  if (key.type === 'Literal') {\n    return '' + key.value;\n  }\n  if (key.type === 'MemberExpression') {\n    return objectKeyToString(key.object) + '.' +\n        objectKeyToString(key.property);\n  }\n  return undefined;\n}\n\nexport const CLOSURE_CONSTRUCTOR_MAP = {\n  'Boolean': 'boolean',\n  'Number': 'number',\n  'String': 'string',\n};\n\n/**\n * AST expression -> Closure type.\n *\n * Accepts literal values, and native constructors.\n *\n * @param {Node} node An Espree expression node.\n * @return {string} The type of that expression, in Closure terms.\n */\nexport function closureType(\n    node: estree.Node, sourceRange: SourceRange): string {\n  if (node.type.match(/Expression$/)) {\n    return node.type.substr(0, node.type.length - 10);\n  } else if (node.type === 'Literal') {\n    return typeof node.value;\n  } else if (node.type === 'Identifier') {\n    return CLOSURE_CONSTRUCTOR_MAP[node.name] || node.name;\n  } else {\n    throw new WarningCarryingException({\n      code: 'no-closure-type',\n      message: `Unable to determine closure type for expression of type ${node\n                   .type}`,\n      severity: Severity.WARNING, sourceRange\n    });\n  }\n}\n\nexport function getAttachedComment(node: estree.Node): string|undefined {\n  const comments =\n      getLeadingComments(node) || getLeadingComments(node['key']) || [];\n  return comments && comments[comments.length - 1];\n}\n\n/**\n * Returns all comments from a tree defined with @event.\n */\nexport function getEventComments(node: estree.Node): ScannedEvent[] {\n  const eventComments = new Set<string>();\n  estraverse.traverse(node, {\n    enter: (node: estree.Node) => {\n      (node.leadingComments || [])\n          .concat(node.trailingComments || [])\n          .map((commentAST) => commentAST.value)\n          .filter((comment) => comment.indexOf('@event') !== -1)\n          .forEach((comment) => eventComments.add(comment));\n    },\n    keys: {Super: []}\n  });\n  return Array.from(eventComments)\n      .map(function(comment) {\n        const annotation =\n            jsdoc.parseJsdoc(jsdoc.removeLeadingAsterisks(comment).trim());\n        return annotateEvent(annotation);\n      })\n      .filter((ev) => !!ev)\n      .sort((ev1, ev2) => ev1.name.localeCompare(ev2.name));\n}\n\nfunction getLeadingComments(node: estree.Node): string[]|undefined {\n  if (!node) {\n    return;\n  }\n  const comments = node.leadingComments;\n  return comments && comments.map((comment) => comment.value);\n}\n\nexport function getPropertyValue(\n    node: estree.ObjectExpression, name: string): estree.Node|undefined {\n  const properties = node.properties;\n  for (const property of properties) {\n    if (objectKeyToString(property.key) === name) {\n      return property.value;\n    }\n  }\n}\n"]}