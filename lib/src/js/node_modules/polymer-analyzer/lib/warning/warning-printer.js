/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const chalk = require("chalk");
const warning_1 = require("./warning");
const defaultPrinterOptions = {
    verbosity: 'full',
    color: true
};
class WarningPrinter {
    constructor(_outStream, _options) {
        this._outStream = _outStream;
        this._options =
            Object.assign({}, defaultPrinterOptions, _options);
        this._chalk = new chalk.constructor({ enabled: !!this._options.color });
    }
    /**
     * Convenience method around `printWarning`.
     */
    printWarnings(warnings) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const warning of warnings) {
                yield this.printWarning(warning);
            }
        });
    }
    printWarning(warning) {
        return __awaiter(this, void 0, void 0, function* () {
            const severity = this._severityToString(warning.severity);
            const range = warning.sourceRange;
            if (this._options.verbosity === 'full') {
                this._outStream.write('\n');
                this._outStream.write((yield this.getUnderlinedText(range, warning.severity)) + '\n\n');
            }
            this._outStream.write(`${range.file}` +
                `(${range.start.line},${range.start.column}) ` +
                `${severity} [${warning.code}] - ${warning.message}\n`);
        });
    }
    _severityToString(severity) {
        const colorFunction = this._severityToColorFunction(severity);
        switch (severity) {
            case warning_1.Severity.ERROR:
                return colorFunction('error');
            case warning_1.Severity.WARNING:
                return colorFunction('warning');
            case warning_1.Severity.INFO:
                return colorFunction('info');
            default:
                const never = severity;
                throw new Error(`Unknown severity value - ${never} - encountered while printing warning.`);
        }
    }
    getUnderlinedText(range, severity) {
        return __awaiter(this, void 0, void 0, function* () {
            const colorFunction = severity == null ?
                (v) => v :
                this._severityToColorFunction(severity);
            const lines = yield this._getLinesOfText(range.start.line, range.end.line, range.file);
            const outputLines = [];
            let lineNum = range.start.line;
            for (const line of lines) {
                outputLines.push(line);
                outputLines.push(colorFunction(getSquiggleUnderline(line, lineNum, range)));
                lineNum++;
            }
            return outputLines.join('\n');
        });
    }
    _severityToColorFunction(severity) {
        switch (severity) {
            case warning_1.Severity.ERROR:
                return this._chalk.red;
            case warning_1.Severity.WARNING:
                return this._chalk.yellow;
            case warning_1.Severity.INFO:
                return this._chalk.green;
            default:
                const never = severity;
                throw new Error(`Unknown severity value - ${never}` +
                    ` - encountered while printing warning.`);
        }
    }
    _getLinesOfText(startLine, endLine, localPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const contents = yield this._options.analyzer.load(localPath);
            return contents.split('\n').slice(startLine, endLine + 1);
        });
    }
}
exports.WarningPrinter = WarningPrinter;
function getSquiggleUnderline(lineText, lineNum, sourceRange) {
    // We're on a middle line of a multiline range. Squiggle the entire line.
    if (lineNum !== sourceRange.start.line && lineNum !== sourceRange.end.line) {
        return '~'.repeat(lineText.length);
    }
    // The tricky case. Might be the start of a multiline range, or it might just
    // be a one-line range.
    if (lineNum === sourceRange.start.line) {
        const startColumn = sourceRange.start.column;
        const endColumn = sourceRange.end.line === sourceRange.start.line ?
            sourceRange.end.column :
            lineText.length;
        const prefix = ' '.repeat(startColumn);
        if (startColumn === endColumn) {
            return prefix + '~'; // always draw at least one squiggle
        }
        return prefix + '~'.repeat(endColumn - startColumn);
    }
    // We're on the end line of a multiline range. Just squiggle up to the end
    // column.
    return '~'.repeat(sourceRange.end.column);
}

//# sourceMappingURL=warning-printer.js.map
