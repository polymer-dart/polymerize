{"version":3,"sources":["analyzer.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;;;;;;;;;;AAEH,oDAAoD;AAEpD,0EAAmE;AAoBnE,wBAAgC,SAAQ,KAAK;CAAG;AAAhD,gDAAgD;AAAA,CAAC;AAKjD;;;;;;;GAOG;AACH;IAEE,YAAY,OAAgB;QAC1B,IAAI,CAAC,aAAa,GAAG,IAAI,6CAAoB,CAAC,OAAO,CAAC,CAAC;IACzD,CAAC;IAED;;;;;;;;;;;;OAYG;IACG,OAAO,CAAC,GAAW,EAAE,QAAiB;;YAC1C,EAAE,CAAC,CAAC,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAC;gBACrB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAC9D,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;QACnD,CAAC;KAAA;IAEK,cAAc;;YAClB,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC;QAC7C,CAAC;KAAA;IAEK,wBAAwB;;YAC5B,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,wBAAwB,EAAE,CAAC;QACvD,CAAC;KAAA;IAED;;;;;;OAMG;IACH,WAAW;QACT,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,CAAC;IACxD,CAAC;IAED;;;;;;OAMG;IACG,IAAI,CAAC,WAAmB,EAAE,gBAAyB;;YACvD,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,EAAE,gBAAgB,CAAC,CAAC;QAChE,CAAC;KAAA;CACF;AAvDD,4BAuDC","file":"analyzer.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/// <reference path=\"../custom_typings/main.d.ts\" />\n\nimport {AnalyzerCacheContext} from './core/analyzer-cache-context';\nimport {Document, Package} from './model/model';\nimport {Parser} from './parser/parser';\nimport {Measurement} from './perf/telemetry';\nimport {Scanner} from './scanning/scanner';\nimport {UrlLoader} from './url-loader/url-loader';\nimport {UrlResolver} from './url-loader/url-resolver';\n\nexport interface Options {\n  urlLoader: UrlLoader;\n  urlResolver?: UrlResolver;\n  parsers?: Map<string, Parser<any>>;\n  scanners?: ScannerTable;\n  /*\n   * Map from url of an HTML Document to another HTML document it lazily depends\n   * on.\n   */\n  lazyEdges?: LazyEdgeMap;\n}\n\nexport class NoKnownParserError extends Error {};\n\nexport type ScannerTable = Map<string, Scanner<any, any, any>[]>;\nexport type LazyEdgeMap = Map<string, string[]>;\n\n/**\n * A static analyzer for web projects.\n *\n * An Analyzer can load and parse documents of various types, and extract\n * arbitratrary information from the documents, and transitively load\n * dependencies. An Analyzer instance is configured with parsers, and scanners\n * which do the actual work of understanding different file types.\n */\nexport class Analyzer {\n  private _cacheContext: AnalyzerCacheContext;\n  constructor(options: Options) {\n    this._cacheContext = new AnalyzerCacheContext(options);\n  }\n\n  /**\n   * Loads, parses and analyzes the root document of a dependency graph and its\n   * transitive dependencies.\n   *\n   * Note: The analyzer only supports analyzing a single root for now. This\n   * is because each analyzed document in the dependency graph has a single\n   * root. This mean that we can't properly analyze app-shell-style, lazy\n   * loading apps.\n   *\n   * @param contents Optional contents of the file when it is known without\n   * reading it from disk. Clears the caches so that the news contents is used\n   * and reanalyzed. Useful for editors that want to re-analyze changed files.\n   */\n  async analyze(url: string, contents?: string): Promise<Document> {\n    if (contents != null) {\n      this._cacheContext = this._cacheContext.filesChanged([url]);\n    }\n    return this._cacheContext.analyze(url, contents);\n  }\n\n  async analyzePackage(): Promise<Package> {\n    return this._cacheContext.analyzePackage();\n  }\n\n  async getTelemetryMeasurements(): Promise<Measurement[]> {\n    return this._cacheContext.getTelemetryMeasurements();\n  }\n\n  /**\n   * Clear all cached information from this analyzer instance.\n   *\n   * Note: if at all possible, instead tell the analyzer about the specific\n   * files that changed rather than clearing caches like this. Caching provides\n   * large performance gains.\n   */\n  clearCaches(): void {\n    this._cacheContext = this._cacheContext.clearCaches();\n  }\n\n  /**\n   * Loads the content at the provided resolved URL.\n   *\n   * Currently does no caching. If the provided contents are given then they\n   * are used instead of hitting the UrlLoader (e.g. when you have in-memory\n   * contents that should override disk).\n   */\n  async load(resolvedUrl: string, providedContents?: string) {\n    return this._cacheContext.load(resolvedUrl, providedContents);\n  }\n}\n"]}