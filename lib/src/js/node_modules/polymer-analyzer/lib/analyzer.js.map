{"version":3,"sources":["analyzer.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;;;;;;;;;;;AAEH,oDAAoD;AAEpD,8DAAwD;AAmBxD,wBAAgC,SAAQ,KAAK;CAAG;AAAhD,gDAAgD;AAAA,CAAC;AAKjD;;;;;;;GAOG;AACH;IAEE,YAAY,OAAgC;QAC1C,EAAE,CAAC,CAAC,OAAO,YAAY,kCAAe,CAAC,CAAC,CAAC;YACvC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAC1B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,CAAC,QAAQ,GAAG,IAAI,kCAAe,CAAC,OAAO,CAAC,CAAC;QAC/C,CAAC;IACH,CAAC;IAED;;;;;;;;;;;;OAYG;IACG,OAAO,CAAC,GAAW,EAAE,QAAiB;;YAC1C,EAAE,CAAC,CAAC,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAC;gBACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACpD,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;QAC9C,CAAC;KAAA;IAEK,cAAc;;YAClB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,CAAC;QACxC,CAAC;KAAA;IAED;;;;;;OAMG;IACH,WAAW;QACT,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;IAC9C,CAAC;IAED;;;;;OAKG;IACH,KAAK;QACH,MAAM,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACrC,CAAC;IAED;;;;;;OAMG;IACG,IAAI,CAAC,WAAmB,EAAE,gBAAyB;;YACvD,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAE,gBAAgB,CAAC,CAAC;QAC3D,CAAC;KAAA;IAED,aAAa,CAAC,GAAW;QACvB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;IAC1C,CAAC;IAED,UAAU,CAAC,GAAW;QACpB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;IACvC,CAAC;CACF;AAzED,4BAyEC","file":"analyzer.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/// <reference path=\"../custom_typings/main.d.ts\" />\n\nimport {AnalysisContext} from './core/analysis-context';\nimport {Document, Package} from './model/model';\nimport {Parser} from './parser/parser';\nimport {Scanner} from './scanning/scanner';\nimport {UrlLoader} from './url-loader/url-loader';\nimport {UrlResolver} from './url-loader/url-resolver';\n\nexport interface Options {\n  urlLoader: UrlLoader;\n  urlResolver?: UrlResolver;\n  parsers?: Map<string, Parser<any>>;\n  scanners?: ScannerTable;\n  /*\n   * Map from url of an HTML Document to another HTML document it lazily depends\n   * on.\n   */\n  lazyEdges?: LazyEdgeMap;\n}\n\nexport class NoKnownParserError extends Error {};\n\nexport type ScannerTable = Map<string, Scanner<any, any, any>[]>;\nexport type LazyEdgeMap = Map<string, string[]>;\n\n/**\n * A static analyzer for web projects.\n *\n * An Analyzer can load and parse documents of various types, and extract\n * arbitrary information from the documents, and transitively load\n * dependencies. An Analyzer instance is configured with parsers, and scanners\n * which do the actual work of understanding different file types.\n */\nexport class Analyzer {\n  private _context: AnalysisContext;\n  constructor(options: Options|AnalysisContext) {\n    if (options instanceof AnalysisContext) {\n      this._context = options;\n    } else {\n      this._context = new AnalysisContext(options);\n    }\n  }\n\n  /**\n   * Loads, parses and analyzes the root document of a dependency graph and its\n   * transitive dependencies.\n   *\n   * Note: The analyzer only supports analyzing a single root for now. This\n   * is because each analyzed document in the dependency graph has a single\n   * root. This mean that we can't properly analyze app-shell-style, lazy\n   * loading apps.\n   *\n   * @param contents Optional contents of the file when it is known without\n   * reading it from disk. Clears the caches so that the news contents is used\n   * and reanalyzed. Useful for editors that want to re-analyze changed files.\n   */\n  async analyze(url: string, contents?: string): Promise<Document> {\n    if (contents != null) {\n      this._context = this._context.filesChanged([url]);\n    }\n    return this._context.analyze(url, contents);\n  }\n\n  async analyzePackage(): Promise<Package> {\n    return this._context.analyzePackage();\n  }\n\n  /**\n   * Clear all cached information from this analyzer instance.\n   *\n   * Note: if at all possible, instead tell the analyzer about the specific\n   * files that changed rather than clearing caches like this. Caching provides\n   * large performance gains.\n   */\n  clearCaches(): void {\n    this._context = this._context.clearCaches();\n  }\n\n  /**\n   * Returns a clone of the analyzer, with the same context, suitable for\n   * running in parallel.\n   *\n   * Note: this feature is experimental.\n   */\n  _fork(): Analyzer {\n    return new Analyzer(this._context);\n  }\n\n  /**\n   * Loads the content at the provided resolved URL.\n   *\n   * Currently does no caching. If the provided contents are given then they\n   * are used instead of hitting the UrlLoader (e.g. when you have in-memory\n   * contents that should override disk).\n   */\n  async load(resolvedUrl: string, providedContents?: string) {\n    return this._context.load(resolvedUrl, providedContents);\n  }\n\n  canResolveUrl(url: string): boolean {\n    return this._context.canResolveUrl(url);\n  }\n\n  resolveUrl(url: string): string {\n    return this._context.resolveUrl(url);\n  }\n}\n"]}