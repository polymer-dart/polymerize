"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const package_1 = require("./package");
const resolvable_1 = require("./resolvable");
/**
 * The metadata for all features and elements defined in one document
 */
class ScannedDocument {
    constructor(document, features, warnings) {
        this.isInline = false;
        // A scanned document has no `sourceRange` or `astNode` by default. However,
        // they can be set later if the ScannedDocument represents an inline doc.
        // TODO(fks): Inherit these two properties from ParsedDocument so that they do
        // not have to be set awkwardly after the fact.
        this.sourceRange = undefined;
        this.astNode = undefined;
        this.document = document;
        this.features = features;
        this.warnings = warnings || [];
        this.isInline = document.isInline;
    }
    get url() {
        return this.document.url;
    }
    /**
     * Gets all features in this scanned document and all inline documents it
     * contains.
     */
    getNestedFeatures() {
        const result = [];
        this._getNestedFeatures(result);
        return result;
    }
    _getNestedFeatures(features) {
        for (const feature of this.features) {
            // Ad hoc test needed here to avoid a problematic import loop.
            if (feature.constructor.name === 'ScannedDocument' &&
                feature['scannedDocument']) {
                const innerDoc = feature['scannedDocument'];
                innerDoc._getNestedFeatures(features);
            }
            else {
                features.push(feature);
            }
        }
    }
}
exports.ScannedDocument = ScannedDocument;
class Document {
    constructor(base, analyzer, languageAnalysis) {
        this.kinds = new Set(['document']);
        this.identifiers = new Set();
        this._localFeatures = new Set();
        /**
         * To handle recursive dependency graphs we must track whether we've started
         * resolving this Document so that we can reliably early exit even if one
         * of our dependencies tries to resolve this document.
         */
        this._begunResolving = false;
        /**
         * True after this document and all of its children are finished resolving.
         */
        this._doneResolving = false;
        this._featuresByKind = null;
        this._featuresByKindAndId = null;
        if (base == null) {
            throw new Error('base is null');
        }
        if (analyzer == null) {
            throw new Error('analyzer is null');
        }
        this._scannedDocument = base;
        this.analyzer = analyzer;
        this.languageAnalysis = languageAnalysis;
        if (!base.isInline) {
            this.identifiers.add(this.url);
        }
        this.kinds.add(`${this.parsedDocument.type}-document`);
        this.warnings = Array.from(base.warnings);
    }
    get url() {
        return this._scannedDocument.url;
    }
    get isInline() {
        return this._scannedDocument.isInline;
    }
    get sourceRange() {
        return this._scannedDocument.sourceRange;
    }
    get astNode() {
        return this._scannedDocument.astNode;
    }
    get parsedDocument() {
        return this._scannedDocument.document;
    }
    get resolved() {
        return this._doneResolving;
    }
    get type() {
        return this.parsedDocument.type;
    }
    /**
     * Resolves all features of this document, so that they have references to all
     * their dependencies.
     *
     * This method can only be called once
     */
    // TODO(justinfagnani): move to ScannedDocument
    resolve() {
        if (this._doneResolving) {
            throw new Error('resolve can only be called once');
        }
        if (this._begunResolving) {
            return;
        }
        this._begunResolving = true;
        this._addFeature(this);
        for (const scannedFeature of this._scannedDocument.features) {
            if (resolvable_1.isResolvable(scannedFeature)) {
                const feature = scannedFeature.resolve(this);
                if (feature) {
                    this._addFeature(feature);
                }
            }
        }
        this._doneResolving = true;
    }
    /**
     * Adds and indexes a feature to this documentled before resolve().
     */
    _addFeature(feature) {
        if (this._doneResolving) {
            throw new Error('_addFeature can not be called after _resolve()');
        }
        this._indexFeature(feature);
        this._localFeatures.add(feature);
    }
    getByKind(kind, options) {
        options = options || {};
        if (this._featuresByKind && options.imported) {
            // We have a fast index! Use that.
            const features = this._featuresByKind.get(kind) || new Set();
            if (!options.externalPackages) {
                return this._filterOutExternal(features);
            }
            return features;
        }
        else if (this._doneResolving && options.imported) {
            // We're done discovering features in this document and its children so
            // we can safely build up the indexes.
            this._buildIndexes();
            return this.getByKind(kind, options);
        }
        return this._getByKind(kind, options);
    }
    getById(kind, identifier, options) {
        options = options || {};
        if (this._featuresByKindAndId && options.imported) {
            // We have a fast index! Use that.
            const idMap = this._featuresByKindAndId.get(kind);
            const features = (idMap && idMap.get(identifier)) || new Set();
            if (!options.externalPackages) {
                return this._filterOutExternal(features);
            }
            return features;
        }
        else if (this._doneResolving && options.imported) {
            // We're done discovering features in this document and its children so
            // we can safely build up the indexes.
            this._buildIndexes();
            return this.getById(kind, identifier, options);
        }
        const result = new Set();
        for (const featureOfKind of this.getByKind(kind, options)) {
            if (featureOfKind.identifiers.has(identifier)) {
                result.add(featureOfKind);
            }
        }
        return result;
    }
    getOnlyAtId(kind, identifier, options) {
        const results = this.getById(kind, identifier, options);
        if (results.size > 1) {
            throw new Error(`Expected to find at most one ${kind} with id ${identifier} ` +
                `but found ${results.size}.`);
        }
        return results.values().next().value || undefined;
    }
    getFeatures(options) {
        options = options || {};
        const result = new Set();
        this._getFeatures(result, new Set(), options);
        return result;
    }
    _getByKind(kind, options) {
        const allFeatures = new Set();
        this._getFeatures(allFeatures, new Set(), options);
        const result = new Set();
        for (const feature of allFeatures) {
            if (feature.kinds.has(kind)) {
                result.add(feature);
            }
        }
        return result;
    }
    _getFeatures(result, visited, options) {
        if (visited.has(this)) {
            return;
        }
        visited.add(this);
        for (const feature of this._localFeatures) {
            result.add(feature);
            if (feature.kinds.has('document')) {
                feature._getFeatures(result, visited, options);
            }
            if (feature.kinds.has('import') && options.imported) {
                const imprt = feature;
                if (options.externalPackages || !package_1.Package.isExternal(imprt.url)) {
                    imprt.document._getFeatures(result, visited, options);
                }
            }
        }
    }
    _filterOutExternal(features) {
        const result = new Set();
        for (const feature of features) {
            if (feature.sourceRange && package_1.Package.isExternal(feature.sourceRange.file)) {
                continue;
            }
            result.add(feature);
        }
        return result;
    }
    /**
     * Get warnings for the document and all matched features.
     */
    getWarnings(options) {
        const warnings = new Set(this.warnings);
        for (const feature of this.getFeatures(options)) {
            for (const warning of feature.warnings) {
                warnings.add(warning);
            }
        }
        return Array.from(warnings);
    }
    toString() {
        return this._toString(new Set()).join('\n');
    }
    _toString(documentsWalked) {
        let result = [`<Document type=${this.parsedDocument.type} url=${this.url}>\n`];
        if (documentsWalked.has(this)) {
            return result;
        }
        documentsWalked.add(this);
        for (const localFeature of this._localFeatures) {
            if (localFeature instanceof Document) {
                result = result.concat(localFeature._toString(documentsWalked).map((line) => `  ${line}`));
            }
            else {
                let subResult = localFeature.toString();
                if (subResult === '[object Object]') {
                    subResult =
                        `<${localFeature.constructor.name} kinds="${Array
                            .from(localFeature.kinds)
                            .join(', ')}" ids="${Array.from(localFeature.identifiers)
                            .join(',')}">}`;
                }
                result.push(`  ${subResult}`);
            }
        }
        return result;
    }
    stringify() {
        const inlineDocuments = Array.from(this._localFeatures)
            .filter((f) => f instanceof Document && f.isInline)
            .map((d) => d.parsedDocument);
        return this.parsedDocument.stringify({ inlineDocuments: inlineDocuments });
    }
    _initIndexes() {
        this._featuresByKind = new Map();
        this._featuresByKindAndId = new Map();
    }
    _indexFeature(feature) {
        if (!this._featuresByKind || !this._featuresByKindAndId) {
            return;
        }
        for (const kind of feature.kinds) {
            const kindSet = this._featuresByKind.get(kind) || new Set();
            kindSet.add(feature);
            this._featuresByKind.set(kind, kindSet);
            for (const id of feature.identifiers) {
                const identifiersMap = this._featuresByKindAndId.get(kind) ||
                    new Map();
                this._featuresByKindAndId.set(kind, identifiersMap);
                const idSet = identifiersMap.get(id) || new Set();
                identifiersMap.set(id, idSet);
                idSet.add(feature);
            }
        }
    }
    _buildIndexes() {
        if (this._featuresByKind) {
            throw new Error('Tried to build indexes multiple times. This should never happen.');
        }
        if (!this._doneResolving) {
            throw new Error(`Tried to build indexes before finished resolving. ` +
                `Need to wait until afterwards or the indexes would be incomplete.`);
        }
        this._initIndexes();
        for (const feature of this.getFeatures({ imported: true, externalPackages: true })) {
            this._indexFeature(feature);
        }
    }
}
exports.Document = Document;

//# sourceMappingURL=document.js.map
