/**
 * @license
 * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
const model_1 = require("../model/model");
const warning_1 = require("../warning/warning");
function isScannedFunction(d) {
    return d['function'] === true;
}
exports.isScannedFunction = isScannedFunction;
/**
 * The metadata for a single polymer element
 */
class ScannedPolymerElement extends model_1.ScannedElement {
    constructor(options) {
        super();
        this.properties = [];
        this.observers = [];
        this.listeners = [];
        this.behaviorAssignments = [];
        // Indicates if an element is a pseudo element
        this.pseudo = false;
        // TODO(justinfagnani): fix this constructor to not be crazy, or remove
        // class altogether.
        const optionsCopy = Object.assign({}, options);
        delete optionsCopy.properties;
        Object.assign(this, optionsCopy);
        if (options.properties) {
            options.properties.forEach((p) => this.addProperty(p));
        }
    }
    addProperty(prop) {
        if (prop.name.startsWith('_') || prop.name.endsWith('_')) {
            prop.private = true;
        }
        this.properties.push(prop);
        const attributeName = propertyToAttributeName(prop.name);
        if (prop.private || !attributeName || !prop.published) {
            return;
        }
        if (!isScannedFunction(prop)) {
            this.attributes.push({
                name: attributeName,
                sourceRange: prop.sourceRange,
                description: prop.description,
                type: prop.type,
                changeEvent: prop.notify ? `${attributeName}-changed` : undefined
            });
        }
        if (prop.notify) {
            this.events.push({
                name: `${attributeName}-changed`,
                description: `Fired when the \`${prop.name}\` property changes.`,
                sourceRange: prop.sourceRange,
                astNode: prop.astNode,
                warnings: []
            });
        }
    }
    resolve(document) {
        return resolveElement(this, document);
    }
}
exports.ScannedPolymerElement = ScannedPolymerElement;
class PolymerElement extends model_1.Element {
    constructor() {
        super();
        this.kinds = new Set(['element', 'polymer-element']);
        this.behaviorAssignments = [];
    }
    emitPropertyMetadata(property) {
        const polymerMetadata = {};
        const polymerMetadataFields = ['notify', 'observer', 'readOnly'];
        for (const field of polymerMetadataFields) {
            if (field in property) {
                polymerMetadata[field] = property[field];
            }
        }
        return { polymer: polymerMetadata };
    }
}
exports.PolymerElement = PolymerElement;
/**
 * Implements Polymer core's translation of property names to attribute names.
 *
 * Returns null if the property name cannot be so converted.
 */
function propertyToAttributeName(propertyName) {
    // Polymer core will not map a property name that starts with an uppercase
    // character onto an attribute.
    if (propertyName[0].toUpperCase() === propertyName[0]) {
        return null;
    }
    return propertyName.replace(/([A-Z])/g, (_, c1) => `-${c1.toLowerCase()}`);
}
function resolveElement(scannedElement, document) {
    // TODO: Copy over all properties better. Maybe exclude known properties not
    //   copied?
    const clone = Object.assign(new PolymerElement(), scannedElement);
    const flatteningResult = getFlattenedAndResolvedBehaviors(scannedElement.behaviorAssignments, document);
    // This has the combined effects of copying the array of warnings from the
    // ScannedElement, and adding in any new ones found when resolving behaviors.
    clone.warnings = clone.warnings.concat(flatteningResult.warnings);
    const behaviors = Array.from(flatteningResult.resolvedBehaviors);
    clone.properties = mergeByName(scannedElement.properties, behaviors.map(b => ({ name: b.className, vals: b.properties })));
    clone.attributes = mergeByName(scannedElement.attributes, behaviors.map(b => ({ name: b.className, vals: b.attributes })));
    clone.events = mergeByName(scannedElement.events, behaviors.map(b => ({ name: b.className, vals: b.events })));
    const domModule = document.getOnlyAtId('dom-module', scannedElement.tagName || '');
    if (domModule) {
        clone.description = scannedElement.description || domModule.comment || '';
        clone.domModule = domModule.node;
        clone.slots = domModule.slots.slice();
    }
    if (scannedElement.pseudo) {
        clone.kinds.add('pseudo-element');
    }
    return clone;
}
function getFlattenedAndResolvedBehaviors(behaviorAssignments, document) {
    const resolvedBehaviors = new Set();
    const warnings = _getFlattenedAndResolvedBehaviors(behaviorAssignments, document, resolvedBehaviors);
    return { resolvedBehaviors, warnings };
}
exports.getFlattenedAndResolvedBehaviors = getFlattenedAndResolvedBehaviors;
function _getFlattenedAndResolvedBehaviors(behaviorAssignments, document, resolvedBehaviors) {
    const warnings = [];
    for (const behavior of behaviorAssignments) {
        const foundBehaviors = document.getById('behavior', behavior.name);
        if (foundBehaviors.size === 0) {
            warnings.push({
                message: `Unable to resolve behavior ` +
                    `\`${behavior.name}\`. Did you import it? Is it annotated with ` +
                    `@polymerBehavior?`,
                severity: warning_1.Severity.ERROR,
                code: 'unknown-polymer-behavior',
                sourceRange: behavior.sourceRange
            });
            // Skip processing this behavior.
            continue;
        }
        if (foundBehaviors.size > 1) {
            warnings.push({
                message: `Found more than one behavior named ${behavior.name}.`,
                severity: warning_1.Severity.WARNING,
                code: 'multiple-polymer-behaviors',
                sourceRange: behavior.sourceRange
            });
        }
        const foundBehavior = Array.from(foundBehaviors)[foundBehaviors.size - 1];
        if (resolvedBehaviors.has(foundBehavior)) {
            continue;
        }
        resolvedBehaviors.add(foundBehavior);
        // Note that we don't care about warnings from transitively resolved
        // behaviors. Those should become warnings on those behaviors themselves.
        _getFlattenedAndResolvedBehaviors(foundBehavior.behaviorAssignments, document, resolvedBehaviors);
    }
    return warnings;
}
function mergeByName(base, inheritFrom) {
    const byName = new Map();
    for (const initial of base) {
        byName.set(initial.name, initial);
    }
    for (const source of inheritFrom) {
        for (const item of source.vals) {
            if (!byName.has(item.name)) {
                const copy = Object.assign({}, item);
                copy.inheritedFrom = source.name;
                byName.set(copy.name, copy);
            }
        }
    }
    return Array.from(byName.values());
}

//# sourceMappingURL=polymer-element.js.map
