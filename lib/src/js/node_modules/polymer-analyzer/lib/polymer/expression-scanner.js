/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dom5 = require("dom5");
const javascript_parser_1 = require("../javascript/javascript-parser");
const model_1 = require("../model/model");
const warning_1 = require("../warning/warning");
const p = dom5.predicates;
const isTemplate = p.hasTagName('template');
const isDataBindingTemplate = p.AND(isTemplate, p.OR(p.hasAttrValue('is', 'dom-bind'), p.hasAttrValue('is', 'dom-if'), p.hasAttrValue('is', 'dom-repeat'), p.parentMatches(p.OR(p.hasTagName('dom-bind'), p.hasTagName('dom-if'), p.hasTagName('dom-repeat'), p.hasTagName('dom-module')))));
/**
 * Given a node, return all databinding templates inside it.
 *
 * A template is "databinding" if polymer databinding expressions are expected
 * to be evaluated inside. e.g. <template is='dom-if'> or <dom-module><template>
 *
 * Results include both direct and nested templates (e.g. dom-if inside
 * dom-module).
 */
function getAllDataBindingTemplates(node) {
    return dom5.queryAll(node, isDataBindingTemplate, [], dom5.childNodesIncludeTemplate);
}
exports.getAllDataBindingTemplates = getAllDataBindingTemplates;
/**
 * A databinding expression.
 */
class DatabindingExpression {
    constructor(astNode, attribute, sourceRange, direction, expressionText, eventName, databindingInto, ast) {
        this.warnings = [];
        /**
         * Toplevel properties on the model that are referenced in this expression.
         *
         * e.g. in {{foo(bar, baz.zod)}} the properties are foo, bar, and baz
         * (but not zod).
         */
        this.properties = [];
        this.astNode = astNode;
        this.attribute = attribute;
        this.sourceRange = sourceRange;
        this.direction = direction;
        this.databindingInto = databindingInto;
        this.expressionText = expressionText;
        this._expressionAst = ast;
        this.eventName = eventName;
        this.locationOffset = {
            line: sourceRange.start.line,
            col: sourceRange.start.column
        };
        this._extractPropertiesAndValidate();
    }
    /**
     * Given an estree node in this databinding expression, give its source range.
     */
    sourceRangeForNode(node) {
        if (!node || !node.loc) {
            return;
        }
        const databindingRelativeSourceRange = {
            file: this.sourceRange.file,
            // Note: estree uses 1-indexed lines, but SourceRange uses 0 indexed.
            start: { line: (node.loc.start.line - 1), column: node.loc.start.column },
            end: { line: (node.loc.end.line - 1), column: node.loc.end.column }
        };
        return model_1.correctSourceRange(databindingRelativeSourceRange, this.locationOffset);
    }
    _extractPropertiesAndValidate() {
        if (this._expressionAst.body.length !== 1) {
            this.warnings.push(this._validationWarning(`Expected one expression, got ${this._expressionAst.body.length}`, this._expressionAst));
            return;
        }
        const expressionStatement = this._expressionAst.body[0];
        if (expressionStatement.type !== 'ExpressionStatement') {
            this.warnings.push(this._validationWarning(`Expect an expression, not a ${expressionStatement.type}`, expressionStatement));
            return;
        }
        let expression = expressionStatement.expression;
        if (expression.type === 'UnaryExpression') {
            if (expression.operator !== '!') {
                this.warnings.push(this._validationWarning('Only the logical not (!) operator is supported.', expression));
                return;
            }
            expression = expression.argument;
        }
        this._extractAndValidateSubExpression(expression, true);
    }
    _extractAndValidateSubExpression(expression, callAllowed) {
        if (expression.type === 'Literal') {
            return;
        }
        if (expression.type === 'Identifier') {
            this.properties.push({
                name: expression.name,
                sourceRange: this.sourceRangeForNode(expression)
            });
            return;
        }
        if (expression.type === 'MemberExpression') {
            this._extractAndValidateSubExpression(expression.object, false);
            return;
        }
        if (callAllowed && expression.type === 'CallExpression') {
            this._extractAndValidateSubExpression(expression.callee, false);
            for (const arg of expression.arguments) {
                this._extractAndValidateSubExpression(arg, false);
            }
            return;
        }
        this.warnings.push(this._validationWarning(`Only simple syntax is supported in Polymer databinding expressions. ` +
            `${expression.type} not expected here.`, expression));
    }
    _validationWarning(message, node) {
        return {
            code: 'invalid-polymer-expression',
            message,
            sourceRange: this.sourceRangeForNode(node),
            severity: warning_1.Severity.WARNING
        };
    }
}
exports.DatabindingExpression = DatabindingExpression;
/**
 * Find and parse Polymer databinding expressions in HTML.
 */
function scanDocumentForExpressions(document) {
    return extractDataBindingsFromTemplates(document, getAllDataBindingTemplates(document.ast));
}
exports.scanDocumentForExpressions = scanDocumentForExpressions;
function scanDatabindingTemplateForExpressions(document, template) {
    return extractDataBindingsFromTemplates(document, [template].concat(getAllDataBindingTemplates(template.content)));
}
exports.scanDatabindingTemplateForExpressions = scanDatabindingTemplateForExpressions;
function extractDataBindingsFromTemplates(document, templates) {
    const results = [];
    const warnings = [];
    for (const template of templates) {
        dom5.nodeWalkAll(template.content, (node) => {
            if (dom5.isTextNode(node) && node.value) {
                extractDataBindingsFromTextNode(document, node, results, warnings);
            }
            if (node.attrs) {
                for (const attr of node.attrs) {
                    extractDataBindingsFromAttr(document, node, attr, results, warnings);
                }
            }
            return false;
        });
    }
    return { expressions: results, warnings };
}
function extractDataBindingsFromTextNode(document, node, results, warnings) {
    const text = node.value || '';
    const dataBindings = findDatabindingInString(text);
    if (dataBindings.length === 0) {
        return;
    }
    const newlineIndexes = findNewlineIndexes(text);
    const nodeSourceRange = document.sourceRangeForNode(node);
    if (!nodeSourceRange) {
        return;
    }
    // We have indexes into the text node, we'll want to correct that so that
    // it's a range relative to the start of the document.
    const startOfTextNodeOffset = {
        line: nodeSourceRange.start.line,
        col: nodeSourceRange.start.column
    };
    for (const dataBinding of dataBindings) {
        const sourceRangeWithinTextNode = indexesToSourceRange(dataBinding.startIndex, dataBinding.endIndex, nodeSourceRange.file, newlineIndexes);
        const sourceRange = model_1.correctSourceRange(sourceRangeWithinTextNode, startOfTextNodeOffset);
        const parseResult = parseExpression(dataBinding.expressionText, sourceRange);
        if (!parseResult) {
            continue;
        }
        if (parseResult.type === 'failure') {
            warnings.push(parseResult.warning);
        }
        else {
            const expression = new DatabindingExpression(node, undefined, sourceRange, dataBinding.direction, dataBinding.expressionText, undefined, 'string-interpolation', parseResult.program);
            for (const warning of expression.warnings) {
                warnings.push(warning);
            }
            results.push(expression);
        }
        ;
    }
}
function extractDataBindingsFromAttr(document, node, attr, results, warnings) {
    if (!attr.value) {
        return;
    }
    const dataBindings = findDatabindingInString(attr.value);
    const attributeValueRange = document.sourceRangeForAttributeValue(node, attr.name, true);
    if (!attributeValueRange) {
        return;
    }
    const attributeOffset = {
        line: attributeValueRange.start.line,
        col: attributeValueRange.start.column
    };
    const newlineIndexes = findNewlineIndexes(attr.value);
    for (const dataBinding of dataBindings) {
        const isFullAttributeBinding = dataBinding.startIndex === 2 &&
            dataBinding.endIndex + 2 === attr.value.length;
        const databindingInto = isFullAttributeBinding ? 'attribute' : 'string-interpolation';
        let expressionText = dataBinding.expressionText;
        let eventName = undefined;
        if (dataBinding.direction === '{') {
            const match = expressionText.match(/(.*)::(.*)/);
            if (match) {
                expressionText = match[1];
                eventName = match[2];
            }
        }
        const sourceRangeWithinAttribute = indexesToSourceRange(dataBinding.startIndex, dataBinding.endIndex, attributeValueRange.file, newlineIndexes);
        const sourceRange = model_1.correctSourceRange(sourceRangeWithinAttribute, attributeOffset);
        const parseResult = parseExpression(expressionText, sourceRange);
        if (!parseResult) {
            continue;
        }
        if (parseResult.type === 'failure') {
            warnings.push(parseResult.warning);
        }
        else {
            const expression = new DatabindingExpression(node, attr, sourceRange, dataBinding.direction, expressionText, eventName, databindingInto, parseResult.program);
            for (const warning of expression.warnings) {
                warnings.push(warning);
            }
            results.push(expression);
        }
    }
}
function findDatabindingInString(str) {
    const expressions = [];
    const openers = /{{|\[\[/g;
    let match;
    while (match = openers.exec(str)) {
        const matchedOpeners = match[0];
        const startIndex = match.index + 2;
        const direction = matchedOpeners === '{{' ? '{' : '[';
        const closers = matchedOpeners === '{{' ? '}}' : ']]';
        const endIndex = str.indexOf(closers, startIndex);
        if (endIndex === -1) {
            // No closers, this wasn't an expression after all.
            break;
        }
        const expressionText = str.slice(startIndex, endIndex);
        expressions.push({ startIndex, endIndex, expressionText, direction });
        // Start looking for the next expression after the end of this one.
        openers.lastIndex = endIndex + 2;
    }
    return expressions;
}
function findNewlineIndexes(str) {
    const indexes = [];
    let prev;
    let index = str.indexOf('\n');
    while (index !== -1) {
        indexes.push(index);
        prev = index;
        index = str.indexOf('\n', prev + 1);
    }
    return indexes;
}
function indexesToSourceRange(startIndex, endIndex, filename, newlineIndexes) {
    let startLineNumLinesIntoText = 0;
    let startOfLineIndex = 0;
    let endLineNumLinesIntoText = 0;
    let endOfLineIndex = 0;
    for (const index of newlineIndexes) {
        if (index < startIndex) {
            startLineNumLinesIntoText++;
            startOfLineIndex = index + 1;
        }
        if (index < endIndex) {
            endLineNumLinesIntoText++;
            endOfLineIndex = index + 1;
        }
        else {
            // Nothing more interesting to do.
            break;
        }
    }
    return {
        file: filename,
        start: {
            line: startLineNumLinesIntoText,
            column: startIndex - startOfLineIndex
        },
        end: { line: endLineNumLinesIntoText, column: endIndex - endOfLineIndex }
    };
}
function parseExpression(content, expressionSourceRange) {
    const expressionOffset = {
        line: expressionSourceRange.start.line,
        col: expressionSourceRange.start.column
    };
    const parseResult = javascript_parser_1.parseJs(content, expressionSourceRange.file, expressionOffset, 'polymer-expression-parse-error');
    if (parseResult.type === 'success') {
        return parseResult;
    }
    // The polymer databinding expression language allows for foo.0 and foo.*
    // formats when accessing sub properties. These aren't valid JS, but we don't
    // want to warn for them either. So just return undefined for now.
    if (/\.(\*|\d+)/.test(content)) {
        return undefined;
    }
    return parseResult;
}

//# sourceMappingURL=expression-scanner.js.map
