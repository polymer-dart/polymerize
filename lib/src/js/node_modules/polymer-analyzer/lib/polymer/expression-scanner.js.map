{"version":3,"sources":["polymer/expression-scanner.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;;;AAEH,6BAA6B;AAK7B,uEAAwD;AACxD,0CAA+E;AAC/E,gDAAqD;AAErD,MAAM,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC;AAC1B,MAAM,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;AAE5C,MAAM,qBAAqB,GAAG,CAAC,CAAC,GAAG,CAC/B,UAAU,EACV,CAAC,CAAC,EAAE,CACA,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,UAAU,CAAC,EAChC,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,EAC9B,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,YAAY,CAAC,EAClC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE,CAChB,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,EACxB,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,EACtB,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,EAC1B,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAI3C;;;;;;;;GAQG;AACH,oCAA2C,IAAoB;IAC7D,MAAM,CAAC,IAAI,CAAC,QAAQ,CAChB,IAAI,EACJ,qBAAqB,EACrB,EAAE,EACF,IAAI,CAAC,yBAAyB,CAAe,CAAC;AACpD,CAAC;AAND,gEAMC;AAED;;GAEG;AACH;IAuCE,YACI,OAAuB,EAAE,SAAwC,EACjE,WAAwB,EAAE,SAAkB,EAAE,cAAsB,EACpE,SAA2B,EAC3B,eAAmD,EACnD,GAAmB;QA/Bd,aAAQ,GAAc,EAAE,CAAC;QAkBlC;;;;;WAKG;QACH,eAAU,GAAoD,EAAE,CAAC;QAQ/D,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,cAAc,GAAG,GAAG,CAAC;QAC1B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,cAAc,GAAG;YACpB,IAAI,EAAE,WAAW,CAAC,KAAK,CAAC,IAAI;YAC5B,GAAG,EAAE,WAAW,CAAC,KAAK,CAAC,MAAM;SAC9B,CAAC;QAEF,IAAI,CAAC,6BAA6B,EAAE,CAAC;IACvC,CAAC;IAED;;OAEG;IACH,kBAAkB,CAAC,IAAiB;QAClC,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;YACvB,MAAM,CAAC;QACT,CAAC;QACD,MAAM,8BAA8B,GAAG;YACrC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI;YAC3B,qEAAqE;YACrE,KAAK,EAAE,EAAC,IAAI,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,EAAC;YACvE,GAAG,EAAE,EAAC,IAAI,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,EAAC;SAClE,CAAC;QACF,MAAM,CAAC,0BAAkB,CACrB,8BAA8B,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;IAC3D,CAAC;IAEO,6BAA6B;QACnC,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YAC1C,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CACtC,gCAAgC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,EACjE,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YAC1B,MAAM,CAAC;QACT,CAAC;QACD,MAAM,mBAAmB,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC;QACzD,EAAE,CAAC,CAAC,mBAAmB,CAAC,IAAI,KAAK,qBAAqB,CAAC,CAAC,CAAC;YACvD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CACtC,+BAA+B,mBAAmB,CAAC,IAAI,EAAE,EACzD,mBAAmB,CAAC,CAAC,CAAC;YAC1B,MAAM,CAAC;QACT,CAAC;QACD,IAAI,UAAU,GAAG,mBAAmB,CAAC,UAAU,CAAC;QAChD,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,iBAAiB,CAAC,CAAC,CAAC;YAC1C,EAAE,CAAC,CAAC,UAAU,CAAC,QAAQ,KAAK,GAAG,CAAC,CAAC,CAAC;gBAChC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CACtC,iDAAiD,EAAE,UAAU,CAAC,CAAC,CAAC;gBACpE,MAAM,CAAC;YACT,CAAC;YACD,UAAU,GAAG,UAAU,CAAC,QAAQ,CAAC;QACnC,CAAC;QACD,IAAI,CAAC,gCAAgC,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;IAC1D,CAAC;IAEO,gCAAgC,CACpC,UAAuB,EAAE,WAAoB;QAC/C,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;YAClC,MAAM,CAAC;QACT,CAAC;QACD,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,YAAY,CAAC,CAAC,CAAC;YACrC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;gBACnB,IAAI,EAAE,UAAU,CAAC,IAAI;gBACrB,WAAW,EAAE,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAE;aAClD,CAAC,CAAC;YACH,MAAM,CAAC;QACT,CAAC;QACD,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,kBAAkB,CAAC,CAAC,CAAC;YAC3C,IAAI,CAAC,gCAAgC,CAAC,UAAU,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;YAChE,MAAM,CAAC;QACT,CAAC;QACD,EAAE,CAAC,CAAC,WAAW,IAAI,UAAU,CAAC,IAAI,KAAK,gBAAgB,CAAC,CAAC,CAAC;YACxD,IAAI,CAAC,gCAAgC,CAAC,UAAU,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;YAChE,GAAG,CAAC,CAAC,MAAM,GAAG,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC;gBACvC,IAAI,CAAC,gCAAgC,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;YACpD,CAAC;YACD,MAAM,CAAC;QACT,CAAC;QACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CACtC,sEAAsE;YAClE,GAAG,UAAU,CAAC,IAAI,qBAAqB,EAC3C,UAAU,CAAC,CAAC,CAAC;IACnB,CAAC;IAEO,kBAAkB,CAAC,OAAe,EAAE,IAAiB;QAC3D,MAAM,CAAC;YACL,IAAI,EAAE,4BAA4B;YAClC,OAAO;YACP,WAAW,EAAE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAE;YAC3C,QAAQ,EAAE,kBAAQ,CAAC,OAAO;SAC3B,CAAC;IACJ,CAAC;CACF;AA7ID,sDA6IC;AAED;;GAEG;AACH,oCAA2C,QAA4B;IACrE,MAAM,CAAC,gCAAgC,CACnC,QAAQ,EAAE,0BAA0B,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;AAC1D,CAAC;AAHD,gEAGC;AAED,+CACI,QAA4B,EAAE,QAAkB;IAClD,MAAM,CAAC,gCAAgC,CACnC,QAAQ,EACR,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,0BAA0B,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACvE,CAAC;AALD,sFAKC;AAED,0CACI,QAA4B,EAAE,SAA6B;IAC7D,MAAM,OAAO,GAA4B,EAAE,CAAC;IAC5C,MAAM,QAAQ,GAAc,EAAE,CAAC;IAC/B,GAAG,CAAC,CAAC,MAAM,QAAQ,IAAI,SAAS,CAAC,CAAC,CAAC;QACjC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,IAAI;YACtC,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBACxC,+BAA+B,CAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;YACrE,CAAC;YACD,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBACf,GAAG,CAAC,CAAC,MAAM,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;oBAC9B,2BAA2B,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;gBACvE,CAAC;YACH,CAAC;YACD,MAAM,CAAC,KAAK,CAAC;QACf,CAAC,CAAC,CAAC;IACL,CAAC;IACD,MAAM,CAAC,EAAC,WAAW,EAAE,OAAO,EAAE,QAAQ,EAAC,CAAC;AAC1C,CAAC;AAED,yCACI,QAA4B,EAC5B,IAAoB,EACpB,OAAgC,EAChC,QAAmB;IACrB,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;IAC9B,MAAM,YAAY,GAAG,uBAAuB,CAAC,IAAI,CAAC,CAAC;IACnD,EAAE,CAAC,CAAC,YAAY,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;QAC9B,MAAM,CAAC;IACT,CAAC;IACD,MAAM,cAAc,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAC;IAChD,MAAM,eAAe,GAAG,QAAQ,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;IAC1D,EAAE,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;QACrB,MAAM,CAAC;IACT,CAAC;IACD,yEAAyE;IACzE,sDAAsD;IACtD,MAAM,qBAAqB,GAAmB;QAC5C,IAAI,EAAE,eAAe,CAAC,KAAK,CAAC,IAAI;QAChC,GAAG,EAAE,eAAe,CAAC,KAAK,CAAC,MAAM;KAClC,CAAC;IACF,GAAG,CAAC,CAAC,MAAM,WAAW,IAAI,YAAY,CAAC,CAAC,CAAC;QACvC,MAAM,yBAAyB,GAAG,oBAAoB,CAClD,WAAW,CAAC,UAAU,EACtB,WAAW,CAAC,QAAQ,EACpB,eAAe,CAAC,IAAI,EACpB,cAAc,CAAC,CAAC;QACpB,MAAM,WAAW,GACb,0BAAkB,CAAC,yBAAyB,EAAE,qBAAqB,CAAE,CAAC;QAE1E,MAAM,WAAW,GACb,eAAe,CAAC,WAAW,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC;QAE7D,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACjB,QAAQ,CAAC;QACX,CAAC;QACD,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;YACnC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;QACrC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,UAAU,GAAG,IAAI,qBAAqB,CACxC,IAAI,EACJ,SAAS,EACT,WAAW,EACX,WAAW,CAAC,SAAS,EACrB,WAAW,CAAC,cAAc,EAC1B,SAAS,EACT,sBAAsB,EACtB,WAAW,CAAC,OAAO,CAAC,CAAC;YACzB,GAAG,CAAC,CAAC,MAAM,OAAO,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAC1C,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACzB,CAAC;YACD,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC3B,CAAC;QAED,CAAC;IACH,CAAC;AACH,CAAC;AAED,qCACI,QAA4B,EAC5B,IAAoB,EACpB,IAAyB,EACzB,OAAgC,EAChC,QAAmB;IACrB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAChB,MAAM,CAAC;IACT,CAAC;IACD,MAAM,YAAY,GAAG,uBAAuB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACzD,MAAM,mBAAmB,GACrB,QAAQ,CAAC,4BAA4B,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACjE,EAAE,CAAC,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC;QACzB,MAAM,CAAC;IACT,CAAC;IACD,MAAM,eAAe,GAAmB;QACtC,IAAI,EAAE,mBAAmB,CAAC,KAAK,CAAC,IAAI;QACpC,GAAG,EAAE,mBAAmB,CAAC,KAAK,CAAC,MAAM;KACtC,CAAC;IACF,MAAM,cAAc,GAAG,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACtD,GAAG,CAAC,CAAC,MAAM,WAAW,IAAI,YAAY,CAAC,CAAC,CAAC;QACvC,MAAM,sBAAsB,GAAG,WAAW,CAAC,UAAU,KAAK,CAAC;YACvD,WAAW,CAAC,QAAQ,GAAG,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;QACnD,MAAM,eAAe,GACjB,sBAAsB,GAAG,WAAW,GAAG,sBAAsB,CAAC;QAClE,IAAI,cAAc,GAAG,WAAW,CAAC,cAAc,CAAC;QAChD,IAAI,SAAS,GAAG,SAAS,CAAC;QAC1B,EAAE,CAAC,CAAC,WAAW,CAAC,SAAS,KAAK,GAAG,CAAC,CAAC,CAAC;YAClC,MAAM,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;YACjD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACV,cAAc,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC1B,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACvB,CAAC;QACH,CAAC;QACD,MAAM,0BAA0B,GAAG,oBAAoB,CACnD,WAAW,CAAC,UAAU,EACtB,WAAW,CAAC,QAAQ,EACpB,mBAAmB,CAAC,IAAI,EACxB,cAAc,CAAC,CAAC;QACpB,MAAM,WAAW,GACb,0BAAkB,CAAC,0BAA0B,EAAE,eAAe,CAAE,CAAC;QACrE,MAAM,WAAW,GAAG,eAAe,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC;QACjE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACjB,QAAQ,CAAC;QACX,CAAC;QACD,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;YACnC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;QACrC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,UAAU,GAAG,IAAI,qBAAqB,CACxC,IAAI,EACJ,IAAI,EACJ,WAAW,EACX,WAAW,CAAC,SAAS,EACrB,cAAc,EACd,SAAS,EACT,eAAe,EACf,WAAW,CAAC,OAAO,CAAC,CAAC;YACzB,GAAG,CAAC,CAAC,MAAM,OAAO,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAC1C,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACzB,CAAC;YACD,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC3B,CAAC;IACH,CAAC;AACH,CAAC;AAQD,iCAAiC,GAAW;IAC1C,MAAM,WAAW,GAAqB,EAAE,CAAC;IACzC,MAAM,OAAO,GAAG,UAAU,CAAC;IAC3B,IAAI,KAAK,CAAC;IACV,OAAO,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACjC,MAAM,cAAc,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAChC,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;QACnC,MAAM,SAAS,GAAG,cAAc,KAAK,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC;QACtD,MAAM,OAAO,GAAG,cAAc,KAAK,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC;QACtD,MAAM,QAAQ,GAAG,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;QAClD,EAAE,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACpB,mDAAmD;YACnD,KAAK,CAAC;QACR,CAAC;QACD,MAAM,cAAc,GAAG,GAAG,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QACvD,WAAW,CAAC,IAAI,CAAC,EAAC,UAAU,EAAE,QAAQ,EAAE,cAAc,EAAE,SAAS,EAAC,CAAC,CAAC;QAEpE,mEAAmE;QACnE,OAAO,CAAC,SAAS,GAAG,QAAQ,GAAG,CAAC,CAAC;IACnC,CAAC;IACD,MAAM,CAAC,WAAW,CAAC;AACrB,CAAC;AAED,4BAA4B,GAAW;IACrC,MAAM,OAAO,GAAG,EAAE,CAAC;IACnB,IAAI,IAAI,CAAC;IACT,IAAI,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAC9B,OAAO,KAAK,KAAK,CAAC,CAAC,EAAE,CAAC;QACpB,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpB,IAAI,GAAG,KAAK,CAAC;QACb,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,GAAG,CAAC,CAAC,CAAC;IACtC,CAAC;IACD,MAAM,CAAC,OAAO,CAAC;AACjB,CAAC;AAED,8BACI,UAAkB,EAClB,QAAgB,EAChB,QAAgB,EAChB,cAAwB;IAC1B,IAAI,yBAAyB,GAAG,CAAC,CAAC;IAClC,IAAI,gBAAgB,GAAG,CAAC,CAAC;IACzB,IAAI,uBAAuB,GAAG,CAAC,CAAC;IAChC,IAAI,cAAc,GAAG,CAAC,CAAC;IACvB,GAAG,CAAC,CAAC,MAAM,KAAK,IAAI,cAAc,CAAC,CAAC,CAAC;QACnC,EAAE,CAAC,CAAC,KAAK,GAAG,UAAU,CAAC,CAAC,CAAC;YACvB,yBAAyB,EAAE,CAAC;YAC5B,gBAAgB,GAAG,KAAK,GAAG,CAAC,CAAC;QAC/B,CAAC;QACD,EAAE,CAAC,CAAC,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC;YACrB,uBAAuB,EAAE,CAAC;YAC1B,cAAc,GAAG,KAAK,GAAG,CAAC,CAAC;QAC7B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,kCAAkC;YAClC,KAAK,CAAC;QACR,CAAC;IACH,CAAC;IACD,MAAM,CAAC;QACL,IAAI,EAAE,QAAQ;QACd,KAAK,EAAE;YACL,IAAI,EAAE,yBAAyB;YAC/B,MAAM,EAAE,UAAU,GAAG,gBAAgB;SACtC;QACD,GAAG,EAAE,EAAC,IAAI,EAAE,uBAAuB,EAAE,MAAM,EAAE,QAAQ,GAAG,cAAc,EAAC;KACxE,CAAC;AACJ,CAAC;AAED,yBAAyB,OAAe,EAAE,qBAAkC;IAC1E,MAAM,gBAAgB,GAAG;QACvB,IAAI,EAAE,qBAAqB,CAAC,KAAK,CAAC,IAAI;QACtC,GAAG,EAAE,qBAAqB,CAAC,KAAK,CAAC,MAAM;KACxC,CAAC;IACF,MAAM,WAAW,GAAG,2BAAO,CACvB,OAAO,EACP,qBAAqB,CAAC,IAAI,EAC1B,gBAAgB,EAChB,gCAAgC,CAAC,CAAC;IACtC,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;QACnC,MAAM,CAAC,WAAW,CAAC;IACrB,CAAC;IACD,yEAAyE;IACzE,6EAA6E;IAC7E,kEAAkE;IAClE,EAAE,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAC/B,MAAM,CAAC,SAAS,CAAC;IACnB,CAAC;IACD,MAAM,CAAC,WAAW,CAAC;AACrB,CAAC","file":"expression-scanner.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as dom5 from 'dom5';\nimport * as estree from 'estree';\nimport * as parse5 from 'parse5';\n\nimport {ParsedHtmlDocument} from '../html/html-document';\nimport {parseJs} from '../javascript/javascript-parser';\nimport {correctSourceRange, LocationOffset, SourceRange} from '../model/model';\nimport {Severity, Warning} from '../warning/warning';\n\nconst p = dom5.predicates;\nconst isTemplate = p.hasTagName('template');\n\nconst isDataBindingTemplate = p.AND(\n    isTemplate,\n    p.OR(\n        p.hasAttrValue('is', 'dom-bind'),\n        p.hasAttrValue('is', 'dom-if'),\n        p.hasAttrValue('is', 'dom-repeat'),\n        p.parentMatches(p.OR(\n            p.hasTagName('dom-bind'),\n            p.hasTagName('dom-if'),\n            p.hasTagName('dom-repeat'),\n            p.hasTagName('dom-module')))));\n\nexport interface Template extends parse5.ASTNode { content: parse5.ASTNode; }\n\n/**\n * Given a node, return all databinding templates inside it.\n *\n * A template is \"databinding\" if polymer databinding expressions are expected\n * to be evaluated inside. e.g. <template is='dom-if'> or <dom-module><template>\n *\n * Results include both direct and nested templates (e.g. dom-if inside\n * dom-module).\n */\nexport function getAllDataBindingTemplates(node: parse5.ASTNode) {\n  return dom5.queryAll(\n      node,\n      isDataBindingTemplate,\n      [],\n      dom5.childNodesIncludeTemplate) as Template[];\n}\n\n/**\n * A databinding expression.\n */\nexport class DatabindingExpression {\n  /**\n   * If databinding into an attribute this is the element whose attribute is\n   * assigned to. If databinding into a text node, this is that text node.\n   */\n  readonly astNode: parse5.ASTNode;\n  /**\n * If databindingInto is 'attribute' this will hold the HTML element\n * attribute that's being assigned to. Otherwise it's undefined.\n */\n  readonly attribute: parse5.ASTAttribute|undefined;\n\n  readonly sourceRange: SourceRange;\n  readonly warnings: Warning[] = [];\n\n  /** The databinding syntax used. */\n  readonly direction: '{'|'[';\n  readonly expressionText: string;\n  private readonly _expressionAst: estree.Program;\n\n\n  readonly databindingInto: 'string-interpolation'|'attribute';\n\n  /**\n   * If this is a two-way data binding, and an event name was specified\n   * (using ::eventName syntax), this is that event name.\n   */\n  readonly eventName: string|undefined;\n\n  private readonly locationOffset: LocationOffset;\n\n  /**\n   * Toplevel properties on the model that are referenced in this expression.\n   *\n   * e.g. in {{foo(bar, baz.zod)}} the properties are foo, bar, and baz\n   * (but not zod).\n   */\n  properties: Array<{name: string, sourceRange: SourceRange}> = [];\n\n  constructor(\n      astNode: parse5.ASTNode, attribute: parse5.ASTAttribute|undefined,\n      sourceRange: SourceRange, direction: '{'|'[', expressionText: string,\n      eventName: string|undefined,\n      databindingInto: 'string-interpolation'|'attribute',\n      ast: estree.Program) {\n    this.astNode = astNode;\n    this.attribute = attribute;\n    this.sourceRange = sourceRange;\n    this.direction = direction;\n    this.databindingInto = databindingInto;\n    this.expressionText = expressionText;\n    this._expressionAst = ast;\n    this.eventName = eventName;\n    this.locationOffset = {\n      line: sourceRange.start.line,\n      col: sourceRange.start.column\n    };\n\n    this._extractPropertiesAndValidate();\n  }\n\n  /**\n   * Given an estree node in this databinding expression, give its source range.\n   */\n  sourceRangeForNode(node: estree.Node) {\n    if (!node || !node.loc) {\n      return;\n    }\n    const databindingRelativeSourceRange = {\n      file: this.sourceRange.file,\n      // Note: estree uses 1-indexed lines, but SourceRange uses 0 indexed.\n      start: {line: (node.loc.start.line - 1), column: node.loc.start.column},\n      end: {line: (node.loc.end.line - 1), column: node.loc.end.column}\n    };\n    return correctSourceRange(\n        databindingRelativeSourceRange, this.locationOffset);\n  }\n\n  private _extractPropertiesAndValidate() {\n    if (this._expressionAst.body.length !== 1) {\n      this.warnings.push(this._validationWarning(\n          `Expected one expression, got ${this._expressionAst.body.length}`,\n          this._expressionAst));\n      return;\n    }\n    const expressionStatement = this._expressionAst.body[0]!;\n    if (expressionStatement.type !== 'ExpressionStatement') {\n      this.warnings.push(this._validationWarning(\n          `Expect an expression, not a ${expressionStatement.type}`,\n          expressionStatement));\n      return;\n    }\n    let expression = expressionStatement.expression;\n    if (expression.type === 'UnaryExpression') {\n      if (expression.operator !== '!') {\n        this.warnings.push(this._validationWarning(\n            'Only the logical not (!) operator is supported.', expression));\n        return;\n      }\n      expression = expression.argument;\n    }\n    this._extractAndValidateSubExpression(expression, true);\n  }\n\n  private _extractAndValidateSubExpression(\n      expression: estree.Node, callAllowed: boolean) {\n    if (expression.type === 'Literal') {\n      return;\n    }\n    if (expression.type === 'Identifier') {\n      this.properties.push({\n        name: expression.name,\n        sourceRange: this.sourceRangeForNode(expression)!\n      });\n      return;\n    }\n    if (expression.type === 'MemberExpression') {\n      this._extractAndValidateSubExpression(expression.object, false);\n      return;\n    }\n    if (callAllowed && expression.type === 'CallExpression') {\n      this._extractAndValidateSubExpression(expression.callee, false);\n      for (const arg of expression.arguments) {\n        this._extractAndValidateSubExpression(arg, false);\n      }\n      return;\n    }\n    this.warnings.push(this._validationWarning(\n        `Only simple syntax is supported in Polymer databinding expressions. ` +\n            `${expression.type} not expected here.`,\n        expression));\n  }\n\n  private _validationWarning(message: string, node: estree.Node): Warning {\n    return {\n      code: 'invalid-polymer-expression',\n      message,\n      sourceRange: this.sourceRangeForNode(node)!,\n      severity: Severity.WARNING\n    };\n  }\n}\n\n/**\n * Find and parse Polymer databinding expressions in HTML.\n */\nexport function scanDocumentForExpressions(document: ParsedHtmlDocument) {\n  return extractDataBindingsFromTemplates(\n      document, getAllDataBindingTemplates(document.ast));\n}\n\nexport function scanDatabindingTemplateForExpressions(\n    document: ParsedHtmlDocument, template: Template) {\n  return extractDataBindingsFromTemplates(\n      document,\n      [template].concat(getAllDataBindingTemplates(template.content)));\n}\n\nfunction extractDataBindingsFromTemplates(\n    document: ParsedHtmlDocument, templates: Iterable<Template>) {\n  const results: DatabindingExpression[] = [];\n  const warnings: Warning[] = [];\n  for (const template of templates) {\n    dom5.nodeWalkAll(template.content, (node) => {\n      if (dom5.isTextNode(node) && node.value) {\n        extractDataBindingsFromTextNode(document, node, results, warnings);\n      }\n      if (node.attrs) {\n        for (const attr of node.attrs) {\n          extractDataBindingsFromAttr(document, node, attr, results, warnings);\n        }\n      }\n      return false;\n    });\n  }\n  return {expressions: results, warnings};\n}\n\nfunction extractDataBindingsFromTextNode(\n    document: ParsedHtmlDocument,\n    node: parse5.ASTNode,\n    results: DatabindingExpression[],\n    warnings: Warning[]) {\n  const text = node.value || '';\n  const dataBindings = findDatabindingInString(text);\n  if (dataBindings.length === 0) {\n    return;\n  }\n  const newlineIndexes = findNewlineIndexes(text);\n  const nodeSourceRange = document.sourceRangeForNode(node);\n  if (!nodeSourceRange) {\n    return;\n  }\n  // We have indexes into the text node, we'll want to correct that so that\n  // it's a range relative to the start of the document.\n  const startOfTextNodeOffset: LocationOffset = {\n    line: nodeSourceRange.start.line,\n    col: nodeSourceRange.start.column\n  };\n  for (const dataBinding of dataBindings) {\n    const sourceRangeWithinTextNode = indexesToSourceRange(\n        dataBinding.startIndex,\n        dataBinding.endIndex,\n        nodeSourceRange.file,\n        newlineIndexes);\n    const sourceRange =\n        correctSourceRange(sourceRangeWithinTextNode, startOfTextNodeOffset)!;\n\n    const parseResult =\n        parseExpression(dataBinding.expressionText, sourceRange);\n\n    if (!parseResult) {\n      continue;\n    }\n    if (parseResult.type === 'failure') {\n      warnings.push(parseResult.warning);\n    } else {\n      const expression = new DatabindingExpression(\n          node,\n          undefined,\n          sourceRange,\n          dataBinding.direction,\n          dataBinding.expressionText,\n          undefined,\n          'string-interpolation',\n          parseResult.program);\n      for (const warning of expression.warnings) {\n        warnings.push(warning);\n      }\n      results.push(expression);\n    }\n\n    ;\n  }\n}\n\nfunction extractDataBindingsFromAttr(\n    document: ParsedHtmlDocument,\n    node: parse5.ASTNode,\n    attr: parse5.ASTAttribute,\n    results: DatabindingExpression[],\n    warnings: Warning[]) {\n  if (!attr.value) {\n    return;\n  }\n  const dataBindings = findDatabindingInString(attr.value);\n  const attributeValueRange =\n      document.sourceRangeForAttributeValue(node, attr.name, true);\n  if (!attributeValueRange) {\n    return;\n  }\n  const attributeOffset: LocationOffset = {\n    line: attributeValueRange.start.line,\n    col: attributeValueRange.start.column\n  };\n  const newlineIndexes = findNewlineIndexes(attr.value);\n  for (const dataBinding of dataBindings) {\n    const isFullAttributeBinding = dataBinding.startIndex === 2 &&\n        dataBinding.endIndex + 2 === attr.value.length;\n    const databindingInto =\n        isFullAttributeBinding ? 'attribute' : 'string-interpolation';\n    let expressionText = dataBinding.expressionText;\n    let eventName = undefined;\n    if (dataBinding.direction === '{') {\n      const match = expressionText.match(/(.*)::(.*)/);\n      if (match) {\n        expressionText = match[1];\n        eventName = match[2];\n      }\n    }\n    const sourceRangeWithinAttribute = indexesToSourceRange(\n        dataBinding.startIndex,\n        dataBinding.endIndex,\n        attributeValueRange.file,\n        newlineIndexes);\n    const sourceRange =\n        correctSourceRange(sourceRangeWithinAttribute, attributeOffset)!;\n    const parseResult = parseExpression(expressionText, sourceRange);\n    if (!parseResult) {\n      continue;\n    }\n    if (parseResult.type === 'failure') {\n      warnings.push(parseResult.warning);\n    } else {\n      const expression = new DatabindingExpression(\n          node,\n          attr,\n          sourceRange,\n          dataBinding.direction,\n          expressionText,\n          eventName,\n          databindingInto,\n          parseResult.program);\n      for (const warning of expression.warnings) {\n        warnings.push(warning);\n      }\n      results.push(expression);\n    }\n  }\n}\n\ninterface RawDatabinding {\n  readonly expressionText: string;\n  readonly startIndex: number;\n  readonly endIndex: number;\n  readonly direction: '{'|'[';\n}\nfunction findDatabindingInString(str: string) {\n  const expressions: RawDatabinding[] = [];\n  const openers = /{{|\\[\\[/g;\n  let match;\n  while (match = openers.exec(str)) {\n    const matchedOpeners = match[0];\n    const startIndex = match.index + 2;\n    const direction = matchedOpeners === '{{' ? '{' : '[';\n    const closers = matchedOpeners === '{{' ? '}}' : ']]';\n    const endIndex = str.indexOf(closers, startIndex);\n    if (endIndex === -1) {\n      // No closers, this wasn't an expression after all.\n      break;\n    }\n    const expressionText = str.slice(startIndex, endIndex);\n    expressions.push({startIndex, endIndex, expressionText, direction});\n\n    // Start looking for the next expression after the end of this one.\n    openers.lastIndex = endIndex + 2;\n  }\n  return expressions;\n}\n\nfunction findNewlineIndexes(str: string) {\n  const indexes = [];\n  let prev;\n  let index = str.indexOf('\\n');\n  while (index !== -1) {\n    indexes.push(index);\n    prev = index;\n    index = str.indexOf('\\n', prev + 1);\n  }\n  return indexes;\n}\n\nfunction indexesToSourceRange(\n    startIndex: number,\n    endIndex: number,\n    filename: string,\n    newlineIndexes: number[]): SourceRange {\n  let startLineNumLinesIntoText = 0;\n  let startOfLineIndex = 0;\n  let endLineNumLinesIntoText = 0;\n  let endOfLineIndex = 0;\n  for (const index of newlineIndexes) {\n    if (index < startIndex) {\n      startLineNumLinesIntoText++;\n      startOfLineIndex = index + 1;\n    }\n    if (index < endIndex) {\n      endLineNumLinesIntoText++;\n      endOfLineIndex = index + 1;\n    } else {\n      // Nothing more interesting to do.\n      break;\n    }\n  }\n  return {\n    file: filename,\n    start: {\n      line: startLineNumLinesIntoText,\n      column: startIndex - startOfLineIndex\n    },\n    end: {line: endLineNumLinesIntoText, column: endIndex - endOfLineIndex}\n  };\n}\n\nfunction parseExpression(content: string, expressionSourceRange: SourceRange) {\n  const expressionOffset = {\n    line: expressionSourceRange.start.line,\n    col: expressionSourceRange.start.column\n  };\n  const parseResult = parseJs(\n      content,\n      expressionSourceRange.file,\n      expressionOffset,\n      'polymer-expression-parse-error');\n  if (parseResult.type === 'success') {\n    return parseResult;\n  }\n  // The polymer databinding expression language allows for foo.0 and foo.*\n  // formats when accessing sub properties. These aren't valid JS, but we don't\n  // want to warn for them either. So just return undefined for now.\n  if (/\\.(\\*|\\d+)/.test(content)) {\n    return undefined;\n  }\n  return parseResult;\n}\n"]}